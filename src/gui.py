# -*- coding: utf-8 -*-

""" All GUI related classes, include some code autogenerated by PyQt  """

import os
import math
import pickle
from PyQt5 import QtCore, QtGui, QtWidgets
import simloop
import mazedlg
import agentdlg
import pandas as pd
import numpy as np


class MazeView(QtWidgets.QGraphicsView):
    """Specialized Qt graphics view object to hold the maze

       This overloading takes care of the mouse controled zoom and scrolling
    """

    def __init__(self, parent=None):
        super(MazeView, self).__init__(parent)
        self.parent = parent
        self.zoom = 1
        self.prevMousePos = None

    def wheelEvent(self, event):
        super(MazeView, self).wheelEvent(event)
        factor = pow(2, 1/10)
        if (event.angleDelta().x() > 0 or event.angleDelta().y() > 0):
            self.zoom = min(self.zoom*factor, 32)
        elif (event.angleDelta().x() < 0 or event.angleDelta().y() < 0):
            self.zoom = max(0.125, self.zoom/factor)

        self.resetTransform()
        self.scale(self.zoom, self.zoom)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:  # or Qt.MiddleButton
            self.prevMousePos = event.pos()
        else:
            super(MazeView, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if event.buttons() == QtCore.Qt.LeftButton:
            offset = self.prevMousePos - event.pos()
            self.prevMousePos = event.pos()

            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() + offset.y())
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() + offset.x())
        else:
            super(MazeView, self).mouseMoveEvent(event)


class GraphicsAgentItem(QtWidgets.QGraphicsItem):
    """Custom agent item.

       It draws a circle with an arrow showing the agent's orientation
    """

    def __init__(self, agent, parent=None):
        super(GraphicsAgentItem, self).__init__(parent)
        # self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)

        self.agent = agent
        
        # Pen and brush for the body
        self.pen = QtGui.QPen(QtGui.QColor(self.agent.color[0],
                                           self.agent.color[1],
                                           self.agent.color[2],
                                           255),
                              1)
        self.brush = QtGui.QBrush(self.pen.color())

        # Pen and blush for the arrow
        self.apen = QtGui.QPen(QtGui.QColor(255, 255, 192, 255), 1)
        self.abrush = QtGui.QBrush(QtCore.Qt.NoBrush)

    def boundingRect(self):
        r = math.ceil(self.agent.radius)
        return QtCore.QRectF(-r, -r, 2*r+1, 2*r+1)

    def paint(self, painter, option, widget):

        self.setPos(self.agent.state.posX, self.agent.state.posY)
        self.setRotation(self.agent.state.angle)

        r = self.agent.radius

        painter.setPen(self.pen)
        painter.setBrush(self.brush)
        painter.drawEllipse(QtCore.QPointF(0.0, 0.0), r, r)

        painter.setPen(self.apen)
        painter.setBrush(self.abrush)

        painter.drawLine(-r, 0, r, 0)
        painter.drawPolyline(QtCore.QPointF(0, r),
                             QtCore.QPointF(r, 0),
                             QtCore.QPointF(0, -r))

    def shape(self):
        path = QtGui.QPainterPath()
        path.addEllipse(self.boundingRect())
        return path

    def setState(self, agent):
        if self.agent is not agent:
            self.agent = agent


class GraphicsObservationsItem(QtWidgets.QGraphicsItem):
    """Custom graphics item for the observation rays.

       It draws lines from the agent position towards the walls.

       This might be time consuming for fast rendering processes, so it
       is managed completely appart from the agent visualization
    """
    def __init__(self, agent, maze, parent=None):
        super(GraphicsObservationsItem, self).__init__(parent)

        # Pen and brush for the body
        self.okPen = QtGui.QPen(QtGui.QColor(0, 192, 0, 128), 1,
                                QtCore.Qt.SolidLine,
                                QtCore.Qt.RoundCap,
                                QtCore.Qt.RoundJoin)
        self.badPen = QtGui.QPen(QtGui.QColor(255, 0, 0, 64), 1,
                                 QtCore.Qt.SolidLine,
                                 QtCore.Qt.RoundCap,
                                 QtCore.Qt.RoundJoin)

        self.maze = maze
        self.agent = agent
        self.bbox = None
        self.goodLines = None
        self.badLines = None

    def boundingRect(self):
        if self.bbox is not None:
            return self.bbox
        else:
            r = math.ceil(self.agent.radius)
            return QtCore.QRectF(-r, -r, 2*r+1, 2*r+1)

    def paint(self, painter, option, widget):

        # The position and rotation is inherited from the parent (agent)
        # self.setPos(self.agent.state.posX, self.agent.state.posY)
        # self.setRotation(self.agent.state.angle)

        # The observations should never leave the maze, because it has
        # an external wall

        # self.setClipRect(-self.agent.state.posX,
        #                  -self.agent.state.posY,
        #                  self.maze.nx*self.maze.cellSizeX,
        #                  self.maze.ny*self.maze.cellSizeY)

        if self.goodLines:
            painter.setPen(self.okPen)
            painter.drawLines(self.goodLines)
        if self.badLines:
            painter.setPen(self.badPen)
            painter.drawLines(self.badLines)

    def shape(self):
        path = QtGui.QPainterPath()
        path.addRect(self.boundingRect())
        return path

    def setState(self, agent):

        self.prepareGeometryChange()

        self.agent = agent

        # We have to construct the proper set of "from-to" pairs
        self.goodLines = []
        self.badLines = []

        bfx = self.maze.nx*self.maze.cellSizeX
        bfy = self.maze.ny*self.maze.cellSizeY
        btx, bty = 0, 0

        r = self.agent.radius+1
        for angle, dist in zip(self.agent.sensorArray,
                               self.agent.observations):
            c = math.cos(math.radians(angle))
            s = math.sin(math.radians(angle))
            if (dist < 0):
                x, y = c*self.agent.maxDistance, s*self.agent.maxDistance
                self.badLines.append(QtCore.QLineF(c*r, s*r, x, y))
            else:
                d1 = dist-1
                x, y = c*d1, s*d1
                if (d1 >= r):
                    self.goodLines.append(QtCore.QLineF(c*r, s*r, x, y))
            bfx, bfy = min(x, bfx), min(y, bfy)
            btx, bty = max(x, btx), max(y, bty)

        self.bbox = QtCore.QRectF(bfx-1, bfy-1, btx-bfx+3, bty-bfy+3)


class Ui_MainWindow(QtCore.QObject):
    """ Main GUI Window """

    renderSignal = QtCore.pyqtSignal()
    pauseSignal = QtCore.pyqtSignal()
    stopSignal = QtCore.pyqtSignal()
    restartSignal = QtCore.pyqtSignal()

    def __init__(self):
        super(Ui_MainWindow, self).__init__()
        self.mazeSeed = 1
        self.simLoop = simloop.SimLoop()
        self.agentItem = None
        self.renderSignal.connect(self.render)
        self.pauseSignal.connect(self.pauseClicked)
        self.stopSignal.connect(self.stopClicked)
        self.restartSignal.connect(self.restartClicked)
        self.mainWnd = None
        self.showSensors = True

    def startThreads(self):
        """ Initialize the simulation threads"""
        self.threadPool = QtCore.QThreadPool()
        self.threadPool.start(self.simLoop.timer)
        self.threadPool.start(self.simLoop)

    def setupUi(self, MainWindow):
        """Build the whole GUI window"""

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1024, 768)
        self.mainWnd = MainWindow
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.mainLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.mainLayout.setObjectName("mainLayout")

        self.canvas = MazeView(self.centralwidget)
        self.canvas.setObjectName("canvas")

        self.mainLayout.addWidget(self.canvas, 0, 0, 1, 1)
        self.buttonsBar = QtWidgets.QHBoxLayout()
        self.buttonsBar.setObjectName("buttonsBar")

        self.playButton = QtWidgets.QPushButton(self.centralwidget)
        self.playButton.setObjectName("playButton")
        self.playButton.clicked.connect(self.playClicked)
        self.buttonsBar.addWidget(self.playButton)

        self.pauseButton = QtWidgets.QPushButton(self.centralwidget)
        self.pauseButton.setObjectName("pauseButton")
        self.pauseButton.clicked.connect(self.pauseClicked)
        self.pauseButton.setEnabled(False)

        self.buttonsBar.addWidget(self.pauseButton)

        self.stepButton = QtWidgets.QPushButton(self.centralwidget)
        self.stepButton.setObjectName("stepButton")
        self.stepButton.clicked.connect(self.stepClicked)
        self.buttonsBar.addWidget(self.stepButton)

        self.stopButton = QtWidgets.QPushButton(self.centralwidget)
        self.stopButton.setObjectName("stopButton")
        self.stopButton.clicked.connect(self.stopClicked)
        self.stopButton.setEnabled(False)

        self.buttonsBar.addWidget(self.stopButton)

        self.restartButton = QtWidgets.QPushButton(self.centralwidget)
        self.restartButton.setObjectName("restartButton")
        self.restartButton.clicked.connect(self.restartClicked)
        self.buttonsBar.addWidget(self.restartButton)

        spacerItem = QtWidgets.QSpacerItem(40, 20,
                                           QtWidgets.QSizePolicy.Minimum,
                                           QtWidgets.QSizePolicy.Minimum)

        self.buttonsBar.addItem(spacerItem)
        self.speedSlider = QtWidgets.QSlider(self.centralwidget)
        self.speedSlider.setOrientation(QtCore.Qt.Horizontal)
        self.speedSlider.setObjectName("speedSlider")
        self.speedSlider.setRange(0, 2000)
        self.speedSlider.setValue(200)
        self.speedSlider.valueChanged.connect(self.speedChanged)
        self.buttonsBar.addWidget(self.speedSlider)
        self.mainLayout.addLayout(self.buttonsBar, 1, 0, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1024, 30))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuMaze = QtWidgets.QMenu(self.menubar)
        self.menuMaze.setObjectName("menuMaze")
        self.menuAgent = QtWidgets.QMenu(self.menubar)
        self.menuAgent.setObjectName("menuAgent")

        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")

        MainWindow.setStatusBar(self.statusbar)

        self.actionLoad_maze = QtWidgets.QAction(MainWindow)
        self.actionLoad_maze.setObjectName("actionLoad_maze")
        self.actionLoad_maze.triggered.connect(self.loadMaze)

        self.actionSave_maze = QtWidgets.QAction(MainWindow)
        self.actionSave_maze.setObjectName("actionSave_maze")
        self.actionSave_maze.triggered.connect(self.saveMaze)

        self.actionQuit = QtWidgets.QAction(MainWindow)
        self.actionQuit.setObjectName("actionQuit")
        self.actionQuit.triggered.connect(self.quit)

        self.mazeConfigDialog = QtWidgets.QDialog(MainWindow)
        self.mazeConfigDialog.ui = mazedlg.MazeDialog(self.mazeConfigDialog)
        self.mazeConfigDialog.ui.setupUi(self.mazeConfigDialog)
        self.mazeConfigDialog.ui.applySignal.connect(self.onBuildNewMaze)

        self.actionConfigMaze = QtWidgets.QAction(MainWindow)
        self.actionConfigMaze.setObjectName("actionConfigMaze")
        self.actionConfigMaze.triggered.connect(self.showMazeConfig)

        self.actionBuild_new = QtWidgets.QAction(MainWindow)
        self.actionBuild_new.setObjectName("actionBuild_new")
        self.actionBuild_new.triggered.connect(self.onBuildNewMaze)

        self.actionLoad_environment = QtWidgets.QAction(MainWindow)
        self.actionLoad_environment.setObjectName("actionLoad_environment")
        self.actionLoad_environment.triggered.connect(self.loadEnvironment)

        self.actionSave_environment = QtWidgets.QAction(MainWindow)
        self.actionSave_environment.setObjectName("actionSave_environment")
        self.actionSave_environment.triggered.connect(self.saveEnvironment)

        self.actionShowSensors = QtWidgets.QAction(MainWindow)
        self.actionShowSensors.setCheckable(True)
        self.actionShowSensors.setChecked(self.showSensors)
        self.actionShowSensors.setObjectName("actionShowSensors")
        self.actionShowSensors.triggered.connect(self.toggleShowSensors)

        self.agentConfigDialog = QtWidgets.QDialog(MainWindow)
        self.agentConfigDialog.ui = agentdlg.AgentDialog(self.agentConfigDialog)
        self.agentConfigDialog.ui.setupUi(self.agentConfigDialog)
        self.agentConfigDialog.ui.applySignal.connect(self.onAgentConfig)

        self.actionConfigAgent = QtWidgets.QAction(MainWindow)
        self.actionConfigAgent.setObjectName("actionConfigAgent")
        self.actionConfigAgent.triggered.connect(self.showAgentConfig)

        self.menuFile.addAction(self.actionLoad_environment)
        self.menuFile.addAction(self.actionSave_environment)
        self.menuFile.addSeparator()
        self.menuFile.addAction(self.actionQuit)
        self.menuMaze.addAction(self.actionConfigMaze)
        self.menuMaze.addAction(self.actionBuild_new)
        self.menuMaze.addSeparator()
        self.menuMaze.addAction(self.actionLoad_maze)
        self.menuMaze.addAction(self.actionSave_maze)
        self.menuAgent.addAction(self.actionShowSensors)
        self.menuAgent.addAction(self.actionConfigAgent)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuMaze.menuAction())
        self.menubar.addAction(self.menuAgent.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Maze RL"))
        self.playButton.setText(_translate("MainWindow", "Play"))
        self.pauseButton.setText(_translate("MainWindow", "Pause"))
        self.stepButton.setText(_translate("MainWindow", "Step"))
        self.stopButton.setText(_translate("MainWindow", "Stop"))
        self.restartButton.setText(_translate("MainWindow", "Restart"))
        self.menuFile.setTitle(_translate("MainWindow", "Fi&le"))
        self.menuMaze.setTitle(_translate("MainWindow", "&Maze"))
        self.menuAgent.setTitle(_translate("MainWindow", "A&gent"))
        self.actionLoad_maze.setText(_translate("MainWindow", "&Load maze"))
        self.actionSave_maze.setText(_translate("MainWindow", "&Save maze"))
        self.actionSave_maze.setShortcut(_translate("MainWindow",
                                                    "Ctrl+Shift+S"))
        self.actionQuit.setText(_translate("MainWindow", "&Quit"))
        self.actionQuit.setShortcut(_translate("MainWindow", "Ctrl+X"))
        self.actionConfigMaze.setText(_translate("MainWindow",
                                                 "&Configure maze"))
        self.actionBuild_new.setText(_translate("MainWindow", "&Build new"))
        self.actionLoad_environment.setText(_translate("MainWindow",
                                                       "&Load environment"))
        self.actionSave_environment.setText(_translate("MainWindow",
                                                       "&Save environment"))
        self.actionSave_environment.setShortcut(_translate("MainWindow",
                                                           "Ctrl+S"))
        self.actionShowSensors.setText(_translate("MainWindow", "&Show sensors"))
        self.actionConfigAgent.setText(_translate("MainWindow", "&Configure agent"))

    def setEnvironment(self, env):
        self.env = env
        self.updateEnvironmentScene()

    def loadEnvironment(self):
        _translate = QtCore.QCoreApplication.translate
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(
            self.mainWnd,
            _translate("MainWindow", "Open environment file"),
            os.path.abspath(os.getcwd()),
            _translate("MainWindow", "Environment files (*.env)"))

        if filename is not None:
            with open(filename, 'rb') as f:
                # This is tricky: the saved environment can have its agent
                # somewhere, but if we are in a stopped state, then that
                # agent's state will be lost.  The simLoop state is almost
                # impossible to save, but if we ensure we are in a
                # stepping mode, we can then easily recover
                self.pauseClicked()
                self.stepClicked()
                self.env, simstate, speed = pickle.load(f)
                self.speedChanged(speed*1000)
                self.speedSlider.setValue(speed*1000)
                print("[DBG] simloop state loaded is: ", simstate)
                self.updateEnvironmentScene()
                # if simstate == simloop.SimState.Stopped:
                #     self.stopClicked()
                if simstate == simloop.SimState.Running:
                    self.playClicked()

                os.chdir(os.path.dirname(os.path.abspath(filename)))

    def saveEnvironment(self):
        _translate = QtCore.QCoreApplication.translate

        dlg = QtWidgets.QFileDialog(self.mainWnd)
        dlg.setWindowTitle(_translate("MainWindow", "Save environment file"))
        dlg.setDirectory(os.path.abspath(os.getcwd()))
        dlg.setNameFilter(_translate("MainWindow",
                                     "Environment files (*.env)"))
        dlg.setDefaultSuffix(".env")
        dlg.setFileMode(QtWidgets.QFileDialog.AnyFile)
        dlg.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)

        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            filename = str(dlg.selectedFiles()[0])
            with open(filename, 'wb') as f:
                pickle.dump((self.env,
                             self.simLoop.state,
                             self.simLoop.stepInterval), f)
                os.chdir(os.path.dirname(os.path.abspath(filename)))

    def loadMaze(self):
        self.stopClicked()
        _translate = QtCore.QCoreApplication.translate
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(
            self.mainWnd,
            _translate("MainWindow", "Open maze file"),
            os.path.abspath(os.getcwd()),
            _translate("MainWindow", "Maze files (*.maze)"))

        if filename is not None:
            with open(filename, 'rb') as f:
                self.env.maze = pickle.load(f)
                self.env.reset()
                self.updateEnvironmentScene()
                os.chdir(os.path.dirname(os.path.abspath(filename)))

            df=pd.read_csv('contadorR.csv')
            l=np.asarray(df)
            self.env.contR=l
            
            df = pd.read_csv('contadorL.csv')
            l = np.asarray(df)
            self.env.contL = l
            
            df = pd.read_csv('contadorA.csv')
            l = np.asarray(df)
            self.env.contA = l
            
            df = pd.read_csv('probabilidadR.csv')
            l = np.asarray(df)
            self.env.probR = l
            
            df = pd.read_csv('probabilidadL.csv')
            l = np.asarray(df)
            self.env.probL = l
            
            df = pd.read_csv('probabilidadA.csv')
            l = np.asarray(df)
            self.env.probA = l

    def saveMaze(self):
        _translate = QtCore.QCoreApplication.translate

        dlg = QtWidgets.QFileDialog(self.mainWnd)
        dlg.setWindowTitle(_translate("MainWindow", "Save maze file"))
        dlg.setDirectory(os.path.abspath(os.getcwd()))
        dlg.setNameFilter(_translate("MainWindow",
                                     "Maze files (*.maze)"))
        dlg.setDefaultSuffix(".maze")
        dlg.setFileMode(QtWidgets.QFileDialog.AnyFile)
        dlg.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)

        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            filename = str(dlg.selectedFiles()[0])
            with open(filename, 'wb') as f:
                pickle.dump(self.env.maze, f)
                os.chdir(os.path.dirname(os.path.abspath(filename)))
                
            cs = pd.DataFrame(data=self.env.contR)
            cs.to_csv('contadorR.csv', float_format='%.4f', index=False)

            cs = pd.DataFrame(data=self.env.contL)
            cs.to_csv('contadorL.csv', float_format='%.4f', index=False)

            cs = pd.DataFrame(data=self.env.contA)
            cs.to_csv('contadorA.csv', float_format='%.4f', index=False)

            cs = pd.DataFrame(data=self.env.probR)
            cs.to_csv('probabilidadR.csv', float_format='%.4f', index=False)

            cs = pd.DataFrame(data=self.env.probL)
            cs.to_csv('probabilidadL.csv', float_format='%.4f', index=False)

            cs = pd.DataFrame(data=self.env.probA)
            cs.to_csv('probabilidadA.csv', float_format='%.4f', index=False)

    def toggleShowSensors(self):        
        self.showSensors = self.actionShowSensors.isChecked()        
        self.render()
        print("[DBG] Show sensors set to",self.showSensors)

    def setStepper(self, stepper):
        self.simLoop.setStepper(stepper)

    def stepper(self):
        return self.simLoop.stepper

    def disableExecution(self):
        self.simLoop.disableExecution()

    def updateEnvironmentScene(self):
        self.scene = self.mazeToScene(self.env.maze)
        self.canvas.setScene(self.scene)

        self.agentItem = GraphicsAgentItem(self.env.agent)
        self.obsItem = GraphicsObservationsItem(self.env.agent,
                                                self.env.maze,
                                                self.agentItem)
        print("[DBG] Adding agent graphic item")
        self.scene.addItem(self.agentItem)
        print("[DBG] Adding observations graphic item")
        self.scene.addItem(self.obsItem)

        print(self.env.agent)

        self.canvas.show()
        self.fitInCanvasView()

        self.simLoop.stepper.reset()

    def onBuildNewMaze(self):
        self.env.maze.build(self.mazeSeed)
        self.env.reset()

        self.updateEnvironmentScene()

        self.mazeSeed += 1

    def onAgentConfig(self):
        self.env.agent.observations = self.env.observe(self.env.agent)
        self.render()
        # print("[DBG] onAgentConfig called")

    def fitInCanvasView(self):

        self.canvas.fitInView(self.scene.sceneRect(),
                              QtCore.Qt.KeepAspectRatio)
        mat = self.canvas.transform()
        self.canvas.zoom = math.sqrt(mat.m11()*mat.m11() + mat.m12()*mat.m12())
        if self.canvas.zoom < 1:
            self.canvas.zoom = 1
            self.canvas.resetTransform()

    def mazeToScene(self, maze):
        """Build the QGraphicsScene with the maze."""

        # Height and width of the maze image (excluding padding), in pixels
        height = maze.ny*maze.cellSizeY + 1
        width = maze.nx*maze.cellSizeX + 1

        scene = QtWidgets.QGraphicsScene(0, 0, width, height)

        # Scaling factors mapping maze coordinates to image coordinates
        scy, scx = maze.cellSizeY, maze.cellSizeX

        startBrush = QtGui.QBrush(QtGui.QColor(192, 255, 192, 64))
        startPen = QtGui.QPen(QtGui.QColor(192, 255, 192, 128), 0)

        scene.addRect(maze.startX*maze.cellSizeX,
                      maze.startY*maze.cellSizeY,
                      maze.cellSizeX,
                      maze.cellSizeY,
                      startPen,
                      startBrush)

        endBrush = QtGui.QBrush(QtGui.QColor(192, 192, 255, 64))
        endPen = QtGui.QPen(QtGui.QColor(192, 192, 255, 128), 0)

        scene.addRect(maze.endX*maze.cellSizeX,
                      maze.endY*maze.cellSizeY,
                      maze.cellSizeX,
                      maze.cellSizeY,
                      endPen,
                      endBrush)

        pen = QtGui.QPen(QtGui.QColor(0, 0, 64, 255), 1)

        # Draw the "South" and "East" walls of each cell, if present (these
        # are the "North" and "West" walls of a neighbouring cell in
        # general, of course).
        for y in range(maze.ny):
            for x in range(maze.nx):
                if maze.cellAt(x, y).walls['S']:
                    x1, y1, x2, y2 = x*scx, (y+1)*scy, (x+1)*scx, (y+1)*scy
                    scene.addLine(x1, y1, x2, y2, pen)
                if maze.cellAt(x, y).walls['E']:
                    x1, y1, x2, y2 = (x+1)*scx, y*scy, (x+1)*scx, (y+1)*scy
                    scene.addLine(x1, y1, x2, y2, pen)

        # Draw the North and West maze border, which won't have been drawn
        # by the procedure above.
        scene.addLine(0, 0, 0, height-1, pen)
        scene.addLine(0, 0, width-1, 0, pen)

        return scene

    def playClicked(self):
        self.playButton.setEnabled(False)
        self.stepButton.setEnabled(False)
        self.pauseButton.setEnabled(True)
        self.stopButton.setEnabled(True)

        self.simLoop.play()

    def pauseClicked(self):
        self.pauseButton.setEnabled(False)
        self.playButton.setEnabled(True)
        self.stepButton.setEnabled(True)
        self.stopButton.setEnabled(True)

        self.simLoop.pause()

    def stepClicked(self):
        self.pauseButton.setEnabled(False)
        self.playButton.setEnabled(True)
        self.stepButton.setEnabled(True)
        self.stopButton.setEnabled(True)

        self.simLoop.step()

    def stopClicked(self):
        self.pauseButton.setEnabled(False)
        self.playButton.setEnabled(True)
        self.stepButton.setEnabled(True)
        self.stopButton.setEnabled(False)

        self.simLoop.stop()

    def restartClicked(self):
        self.playButton.setEnabled(False)
        self.stepButton.setEnabled(False)
        self.pauseButton.setEnabled(True)
        self.stopButton.setEnabled(True)

        self.simLoop.restart()

    def speedChanged(self, value):
        # print("[DBG] Setting new interval to ", value, "ms")
        self.simLoop.setInterval(value/1000.0)
        self.statusbar.showMessage("Interval set to {}ms".format(value),
                                   1000)

    def render(self):
        """Called only within the GUI thread to trigger an environment
           rendering.

           To enforce another thread into calling this method, just
            emit the signal renderSignal in this gui
        """

        if self.agentItem is not None:
            # print("[DBG] MainWindow.render(): we got called by a signal?")
            # print("[DBG]   reported state: ",self.env.agent.state)
            self.agentItem.setState(self.env.agent)
            self.agentItem.update()
        
        if self.obsItem is not None:
            if self.showSensors and self.env.agent.sensors:                
                self.obsItem.setState(self.env.agent)
                self.obsItem.show()
                self.obsItem.update()
            else:
                self.obsItem.hide()
                if self.showSensors:
                    print("WARNING: sensors not shown, as agent has none")

    def quit(self, arg=None):
        self.simLoop.timer.quit()
        self.simLoop.quit()
        self.threadPool.waitForDone(1000)  # Wait 1s for everything to end
        QtCore.QCoreApplication.quit()

    def __del__(self):
        self.simLoop.timer.quit()
        self.simLoop.quit()

    def closeEvent(self, event):
        quit(self, event)

    def showMazeConfig(self):
        self.mazeConfigDialog.ui.setValues(self.env.maze)
        self.mazeConfigDialog.show()

    def showAgentConfig(self):
        self.agentConfigDialog.ui.setValues(self.env.agent)
        self.agentConfigDialog.show()
